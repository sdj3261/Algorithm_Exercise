대학 신입생과 재학생이 일렬로 서있습니다. 이중 일부 학생을 선정해서 그룹을 만들려 합니다. 단, 그룹은 한 개만 만들어야 합니다. 학생을 선정하는 규칙은 다음과 같습니다.

그룹에 속한 학생들은 모두 좌, 우로 인접해서 서있어야 합니다. 즉, 그룹에 속한 학생들 사이에 그룹에 속하지 않은 학생이 서있으면 안 됩니다.
그룹에는 재학생이 정확히 k명 포함되어야 합니다.
그룹에 포함되는 신입생의 수에는 제한이 없습니다.
신입생이 포함되지 않아도 됩니다(즉, 재학생만으로 이루어진 그룹을 만들어도 괜찮습니다)
다음은 학생 4명이 일렬로 서있고, 그룹에 재학생이 1명(k = 1) 포함되어야 하는 경우의 예시입니다.

group_7.png

0은 신입생, 1은 재학생을 나타냅니다. 이때, 다음과 같이 조건에 맞게 그룹을 만들 수 있습니다.

group_3.png

위 6가지 경우 외에 재학생 1명이 반드시 포함되도록 그룹 한 개를 만드는 경우는 없습니다.

일렬로 서있는 학생들의 정보가 담긴 정수 배열 student, 그룹에 정확히 포함되어야 하는 재학생 수를 나타내는 정수 k가 매개변수로 주어집니다. 조건에 맞게 그룹 한 개를 만드는 방법은 모두 몇 가지인지 return 하도록 solution 함수를 완성해주세요.

제한사항
1 ≤ student의 길이 ≤ 100
0 ≤ student의 원소 ≤ 1
즉, student의 원소는 0 또는 1로만 이루어져 있습니다.
0은 신입생, 1은 재학생을 나타냅니다.
1 ≤ k ≤ 100
그룹을 하나도 만들지 못하는 경우 0을 return 해주세요.
입출력 예
student	k	result
[0,1,0,0]	1	6
[0, 1, 0, 0, 1, 1, 0]	2	8
[0, 1, 0]	2	0


====
2.
당신은 검색 기능을 가진 사이트를 운영하고 있습니다. 당신은 매월 초마다 전월의 최고의 이슈 검색어를 조사하고 있습니다. 최고의 이슈 검색어를 조사하는 방법은 아래와 같습니다.

전월의 사용자들의 검색 기록을 일 기준으로 나눈 research가 주어집니다.
research를 일 기준으로 어떤 검색어가 몇 번 검색되었는지 정리합니다.
어떤 검색어가 연속된 n일 동안 매일 최소 k 번 이상 검색되고, 같은 연속된 n일 동안 총 2 x n x k번 이상 검색되었을 경우 이슈 검색어가 됩니다.
예를 들어, n이 3이고 k가 50이면 그 전월에서 임의의 연속된 3일을 골랐을 때, 매일 50번 이상씩 검색되고 같은 기간 동안 총 300번 이상 검색되면 이슈 검색어가 됩니다.
이슈 검색어 중에서 가장 여러 번 이슈 검색어가 된 검색어가 최고의 이슈 검색어가 됩니다.
가장 여러 번 이슈 검색어가 된 검색어가 여러 개일 경우 사전 순으로 빠른 검색어가 최고의 이슈 검색어가 됩니다.
예를 들어, "a"가 2번 이슈 검색어가 되었고 "c"도 2번 이슈 검색어가 되었다면 "a"가 최고의 이슈 검색어가 됩니다.
그 전월의 사용자들의 검색 기록을 일 기준으로 나눈 1차원 문자열 배열 research, 정수 n, k가 매개변수로 주어집니다. 그 전월의 최고의 이슈 검색어를 조사하여 return 하도록 solution 함수를 완성해 주세요. 최고의 이슈 검색어가 없으면 "None"을 return해 주세요.

제한사항
2 ≤ research의 길이(=그 전월의 일 수) ≤ 30
2 ≤ research의 원소의 길이 ≤ 100
research의 원소는 "검색어1검색어2..." 형태입니다. 하루 동안 검색된 검색어를 순서 없이 붙여 놓은 형태입니다.
검색어의 길이 = 1
검색어는 알파벳 소문자 중 하나입니다.
검색어는 서로 겹칠 수 있습니다.
예를 들어, "abaa"는 하루에 "a"가 3번 "b"가 1번 검색됐다는 뜻입니다.
research에는 1일부터 하루 동안 검색된 검색어들이 차례대로 담겨져있습니다.
1 ≤ n ≤ research의 길이
1 ≤ k ≤ 100
입출력 예
research	n	k	result
["abaaaa","aaa","abaaaaaa","fzfffffffa"]	2	2	"a"
["yxxy","xxyyy"]	2	1	"x"
["yxxy","xxyyy","yz"]	2	1	"y"
["xy","xy"]	1	1	"None"
입출력 예 설명
입출력 예 #1

총 4일 동안의 검색 기록이 주어졌습니다.
아래 표는 전월의 모든 검색어를 날마다 몇 번 검색되었는지 정리한 표입니다.

검색어	1일	2일	3일	4일
a	5	3	7	1
b	1	0	1	0
f	0	0	0	8
z	0	0	0	1
연속된 2(=n)일 동안 날마다 2(=k)번 이상 검색되고, 같은 연속된 2(=n)일 동안 총 8번(=2 x 2 x 2) 이상 검색된 검색어는 1일부터 2일까지 그리고 2일부터 3일까지 검색된 "a"뿐입니다. (4일에 k번 미만으로 검색되었으므로 3일부터 4일까지의 "a"는 이슈 검색어가 아닙니다.) 1일부터 2일까지 그리고 2일부터 3일까지 두 번 이슈 검색어가 된 "a"를 제외한 다른 검색어는 한 번도 이슈 검색어가 되지 못했습니다.
따라서 "a"를 return 합니다.

3.
당신은 밀려드는 많은 작업을 효율적으로 처리하기 위해 다음과 같은 규칙에 따라 일을 하려고 합니다. 모든 작업은 각각의 중요도를 갖고 있으며, 처리하는 방식에 따라 여러 분류로 나눠집니다. 같은 처리 방식에 익숙해지면 편하게 일을 할 수 있기 때문에, 어떤 분류의 작업을 처리하기로 했다면 해당 분류의 작업들을 모두 끝마칠 때까지 작업을 처리합니다. 처리하는 도중이거나 처리가 끝남과 동시에 같은 분류의 작업이 새로 요청되었다면, 새로운 작업도 이어서 처리합니다. 한 분류에 속하는 모든 작업을 끝냈다면, 계속해서 다른 분류 중 작업의 중요도 합이 가장 높은 분류를 선택하여 처리합니다. 만약 중요도 합이 가장 높은 분류가 여러 개라면, 분류 번호가 가장 낮은 분류를 선택하여 처리합니다.

위와 같은 규칙에 따라 분류를 옮겨가면서 모든 일을 처리했을 때, 처리한 분류 번호의 순서를 알아보고자 합니다.

아래 표는 요청 시각을 기준으로 정렬한 작업 목록입니다. 이 문제에서 요청 시각이 같은 작업은 주어지지 않습니다.

번호	요청 시각(초)	걸리는 시간(초)	분류 번호	중요도
1번	1	5	2	3
2번	2	2	3	2
3번	3	1	3	3
4번	5	2	1	5
5번	7	1	1	1
6번	9	1	1	1
7번	10	2	2	9
1초: 요청 시각이 가장 빠른 1번 작업(분류: 2)을 선택합니다. 처리에 걸리는 시간은 5초입니다.
1초~6초: 1번 작업을 처리합니다. 그동안 2번, 3번, 4번 작업이 새로 요청되어 대기합니다.
6초: 분류 3에 속한 2번, 3번 작업의 중요도 합은 5입니다. 분류 1에 속한 4번 작업의 중요도는 5입니다. 중요도가 같다면 분류 번호가 낮은 분류를 선택합니다. 따라서 분류 1의 작업을 선택합니다.
6초~9초: 4번 작업을 8초까지 처리합니다. 그동안 같은 분류인 5번 작업이 요청되었습니다. 따라서 5번 작업을 이어서 9초까지 처리합니다.
9초~10초: 분류 1의 작업을 끝냄과 동시에 같은 분류인 6번 작업이 요청됩니다. 방금 처리가 끝난 분류와 새로 요청된 작업의 분류가 같은 경우, 이어서 해당 분류의 작업을 처리합니다. 따라서, 6번 작업을 이어서 처리합니다.
10초: 6번 작업을 처리함과 동시에 분류 2의 7번 작업이 요청됩니다. 어떤 분류의 작업을 모두 마침과 동시에 다른 분류의 작업 요청이 들어오면, 해당 요청까지 고려하여 다음 분류를 선택합니다. 따라서, 중요도 합이 더 높은 분류 2의 7번 작업을 처리합니다.
10초~12초: 7번 작업을 처리합니다.
12초~15초: 분류 3에 속한 2번과 3번 작업을 처리합니다.
따라서 위 예시에서는 분류를 2 → 1 → 2 → 3 순서대로 옮기며 작업을 처리했습니다.

작업의 요청 시각, 처리하는데 걸리는 시간, 분류, 중요도를 담은 2차원 정수 배열 jobs가 매개변수로 주어집니다. 위 규칙대로 작업을 처리했을 때, 처리한 분류 번호를 시간 순서대로 담아 return 하도록 solution 함수를 완성해주세요. 단, 어떤 분류의 작업을 이어서 처리하지 않았더라도 같은 분류 번호가 연속해서 나오지 않도록 주의해주세요. 예를 들어, 처리한 작업의 분류 순서가 1 → 1 → 2 → 1 이라면, 배열 [1, 2, 1]을 return 합니다.

제한사항
1 ≤ jobs의 길이 ≤ 10,000
jobs의 원소는 [a, b, c, d] 형태입니다.
a는 작업이 요청된 시각을 의미합니다. 모든 작업의 요청 시각은 서로 다릅니다.
jobs는 요청 시각을 기준으로 오름차순 정렬되어 있습니다.
0 ≤ a ≤ 1,000,000
b는 작업을 처리하는데 걸리는 시간을 의미합니다.
1 ≤ b ≤ 10,000
c는 작업의 분류 번호를 의미합니다.
1 ≤ c ≤ 100
d는 작업의 중요도를 의미합니다.
1 ≤ d ≤ 100
입출력 예
jobs	result
[[1, 5, 2, 3], [2, 2, 3, 2], [3, 1, 3, 3], [5, 2, 1, 5], [7, 1, 1, 1], [9, 1, 1, 1], [10, 2, 2, 9]]	[2, 1, 2, 3]
[[1, 2, 1, 5], [2, 1, 2, 100], [3, 2, 1, 5], [5, 2, 1, 5]]	[1, 2]
[[0, 2, 3, 1], [5, 3, 3, 1], [10, 2, 4, 1]]	[3, 4]
[[0, 5, 1, 1], [2, 4, 3, 3], [3, 4, 4, 5], [5, 2, 3, 2]]	[1, 3, 4]

===

다음과 같은 어떤 배열을 섞는 과정을 정의합니다.

주어진 배열의 길이(len이라고 정의합니다.)를 나누었을 때 나머지가 0이 되는 가장 작은 소수 p를 찾습니다. len=1 이라면 과정을 종료합니다.
각 길이가 len/p인 p개의 작은 배열 arr[1], arr[2], ..., arr[p]를 만듭니다.
기존 배열의 원소를 작은 것부터 큰 것까지 arr[1], arr[2], ..., arr[p], arr[1], arr[2], ... 순서로 넣습니다. 즉, arr[1]에 첫 번째 원소, arr[2]에 두 번째 원소, ..., arr[p]에 p번째 원소, arr[1]에 p+1번째 원소, arr[2]에 p+2번째 원소, ..., arr[p]에 마지막 원소를 넣습니다.
p개 배열에 대해 같은 과정을 반복하고 기존 배열을 arr[1], arr[2], ..., arr[p]를 순서대로 이어 붙인 결과로 대체합니다.
예를 들어, 다음 그림은 n=12 일 때 배열을 섞는 과정을 표현한 것입니다.

ex12.png

[1,2,3,4,5,6,7,8,9,10,11,12]를 섞을 때, p=2이므로, 두 개의 배열 arr[1], arr[2]를 만들고, 1부터 12까지 오름차순 순서대로 번갈아가면서 두 배열에 원소를 분배합니다. 그 결과는 [1,3,5,7,9,11], [2,4,6,8,10,12]이고, 두 배열을 각각 재귀적으로 섞은 뒤 다시 합칩니다.
[2,6,10]을 섞을 때, p=3이므로, 세 개의 배열 arr[1], arr[2], arr[3]을 만들고, 2, 6, 10을 오름차순 순서대로 번갈아가면서 세 배열에 원소를 분배합니다. 그 결과는 [2], [6], [10]이고, 세 배열을 각각 재귀적으로 섞은 뒤 다시 합칩니다.
이런 식으로 모든 과정을 완료하면 최종 결과는 [1,5,9,3,7,11,2,6,10,4,8,12]가 됩니다.
정수 n이 매개변수로 주어졌을 때, 1, 2, 3, ..., n 으로 배열을 만들고 문제에 주어진 과정을 통해 그 배열을 섞었을 때 결과로 나오는 배열을 return 하도록 solution 함수를 완성해주세요.

제한사항
2 ≤ n ≤ 1,000,000
입출력 예
n	result
12	[1,5,9,3,7,11,2,6,10,4,8,12]
18	[1,7,13,3,9,15,5,11,17,2,8,14,4,10,16,6,12,18]

브라운은 자신이 만든 모바일 게임에, 이벤트 참여를 위해 동일한 유저가 여러 닉네임과 이메일로 중복 가입했다는 제보를 받았습니다. 고심하던 브라운은 다음과 같은 기준으로 두 유저가 동일한 유저인지 판단하려고 합니다.

어떤 두 유저의 닉네임과 이메일 주소가 모두 유사하면 동일한 유저라고 판단합니다. 또한 (a, b)가 동일 유저이고 (b, c)가 동일 유저라면, (a, c)는 동일 유저라고 간주합니다.

[I. 닉네임 유사성 판단 기준]

어떤 두 닉네임에서, 총 2개 이하의 문자를 삭제하여 동일하게 만들 수 있다면 두 닉네임은 유사하다고 판단합니다.
imhero111, imher1111은 각각 하나의 문자를 삭제하여 동일하게 만들 수 있으므로, 유사한 닉네임입니다.
imhero111
imher1111
imhero111, hero111은 첫 닉네임에서 두 개의 문자를 삭제하여 동일하게 만들 수 있으므로, 유사한 닉네임입니다.
imhero111
hero111
money55man, moneymann은 다음과 같이 최소 3개의 문자를 삭제해야만 동일하게 만들 수 있으므로, 유사한 닉네임이 아닙니다.
money55man
moneymann
[II. 이메일 주소 유사성 판단 기준]

이메일 주소는 @ 기호 앞부분인 계정이름과 뒷부분인 서버이름으로 나누어집니다.

예) ace12Boy@abcd.com
ace123Boy가 계정이름이며, abcd.com이 서버이름입니다.
다음 2개의 조건 중, 하나 이상에 해당하면 유사한 이메일이라고 판단합니다.

어떤 두 이메일 주소의 계정이름에서, 총 1개의 문자를 삭제하여 전체 이메일 주소를 동일하게 만들 수 있으면 유사하다고 판단합니다.
superman5@abcd.com, superyman5@abcd.com은 계정이름에서 총 1개의 문자를 삭제하여 전체 이메일 주소를 동일하게 만들 수 있으므로 유사한 이메일입니다.
superman5@abcd.com
superyman5@abcd.com
aaabaaa@qwer.pe, aaaaaa@abcd.pe는 계정이름 부분만 놓고 보면 1개의 문자를 삭제하여 동일하게 만들 수 있지만, 서버이름이 달라서 전체 이메일 주소가 같아질 수 없으므로, 유사한 이메일이 아닙니다.
aaabaaa@qwer.pe
aaaaaa@abcd.pe
어떤 두 이메일 주소의 계정이름이 동일하면, 서버이름과 상관없이 유사하다고 판단합니다.
superman@abcd.com, superman@erty.net은 서버이름은 다르지만, 계정이름이 동일하므로 유사한 이메일 주소입니다.
superman@abcd.com
superman@erty.net
브라운이 만든 모바일 게임에 가입된 유저들의 닉네임이 담긴 문자열 배열 nicks, 이메일 주소가 담긴 문자열 배열 emails가 매개변수로 주어집니다. 위에서 주어진 기준으로 동일 유저를 판단했을 때, 실제로 가입한 유니크(Unique) 유저의 수를 return 하도록 solution 함수를 완성해주세요.

제한사항
nicks에는 1번 유저의 닉네임부터 차례대로 담겨있습니다.
1 ≤ nicks의 길이 ≤ 100
3 ≤ nicks의 원소의 길이 ≤ 20
nicks의 원소는 알파벳 소문자와 숫자로만 이루어진 문자열입니다.
nicks에 중복된 원소는 담겨있지 않습니다. 즉, 모든 닉네임은 서로 다릅니다.
emails에는 1번 유저의 이메일 주소부터 차례대로 담겨있습니다.
emails의 길이 = nicks의 길이
9 ≤ emails의 원소의 길이 ≤ 41
emails의 원소는 알파벳 소문자, 숫자, 특수문자('@', '.')로만 이루어진 문자열입니다.
emails의 각 원소에서, '@'는 정확히 1번만 등장합니다.
emails의 각 원소는 "계정이름@서버이름" 형식입니다.
3 ≤ 계정이름의 길이 ≤ 20
계정이름은 알파벳 소문자와 숫자로만 이루어진 문자열입니다.
5 ≤ 서버이름의 길이≤ 20
서버이름은 알파벳 소문자와 특수문자('.')로만 이루어진 문자열입니다.
emails에 중복된 원소는 담겨있지 않습니다. 즉, 모든 이메일은 서로 다릅니다.
emails에 담긴 모든 이메일 주소는 올바른 형식의 이메일 주소라고 가정합니다.
입출력 예
nicks	emails	result
["imhero111", "moneyman", "hero111", "imher1111", "hro111", "mmoneyman", "moneymannnn"]	["superman5@abcd.com", "batman432@korea.co.kr", "superman@abcd.com", "supertman5@abcd.com", "superman@erty.net", "batman42@korea.co.kr", "batman432@usa.com"]	3
["99police", "99poli44"]	["687ufq687@aaa.xx.yyy", "87ufq687@aaa.xx.yyy"]	2
["99polico", "99policd"]	["687ufq687@aaa.xx.yyy", "587ufq687@aaa.xx.yyy"]	2
입출력 예 설명
입출력 예 #1

닉네임	이메일 주소
imhero111	superman5@abcd.com
hero111	superman@abcd.com

한 온라인 쇼핑몰에서 재구매율을 기준으로 상품을 정렬하는 기능을 추가하려고 합니다. 재구매율은 어떤 상품을 구매한 모든 고객들 중 해당 상품을 다시 구매하는 고객들의 비중이 얼마나 높은지 나타내는 지표입니다.
재구매율을 계산하는 방법은 아래와 같습니다.

재구매율 = (상품을 재구매한 고객 수) / (상품을 한 번 이상 구매한 고객 수) * 100
재구매율을 구할 때 중요한 것은 통계를 내고자 하는 기간을 정하는 것입니다. 기간을 정하지 않고 단순히 위의 식을 이용해 재구매율을 계산하면, 일반적으로 출시된 지 오래된 상품이 재구매율이 높아 보이는 문제가 발생합니다. 따라서 재구매율을 구하고자 하는 기준 날짜와 그 기간(=재구매 기간)을 정한 뒤 재구매율을 계산하려고 합니다.

아래 표는 구입 기록을 나타내는 예시이며, 날짜를 기준으로 오름차순 정렬되어 있습니다. 이 문제에서 모든 달은 30일까지 있다고 가정합니다. 다시 말해, 1월도 31일이 아닌 30일까지만 존재한다고 가정하며 2월 또한 30일까지 존재한다고 가정합니다.

날짜	유저 아이디	상품 아이디
2020-02-02	uid1	pid1
2020-02-26	uid1	pid1
2020-02-26	uid2	pid1
2020-02-27	uid3	pid2
2020-02-28	uid4	pid2
2020-02-29	uid3	pid3
2020-03-01	uid4	pid3
2020-03-03	uid1	pid1
2020-03-04	uid2	pid1
2020-03-05	uid3	pid2
2020-03-05	uid3	pid3
2020-03-05	uid3	pid3
2020-03-06	uid1	pid4
모든 고객과 상품은 각자 고유한 아이디를 가집니다. 유저의 아이디는 uid로, 상품의 아이디는 pid로 시작하며 뒤에 자연수 번호가 붙습니다. 편의상 고객과 상품을 번호로 부르겠습니다. 상품 1, 2, 3, 4의 재구매 기간은 10일로 동일합니다. 재구매율을 계산하고자 하는 기준 날짜는 3월 5일입니다. 다음과 같이 각 상품의 재구매율을 구할 수 있습니다.



재구매율을 구하는 기간은 기준 날짜인 3월 5일을 포함한 10일간입니다. 따라서 2월 26일부터 3월 5일까지의 기록을 바탕으로 계산합니다. 모든 달이 30일까지 있다는 점에 주의합니다.

1번 상품을 구입한 고객은 2명이며, 2명 모두 1번 상품을 재구매한 고객입니다. 따라서 재구매율은 100%입니다.
2번 상품을 구입한 고객은 3번 고객과 4번 고객입니다. 4번 고객은 2번 상품을 한 번 구매한 고객이며, 3번 고객은 2번 상품을 두 번 구매한 고객입니다. 따라서 재구매율은 50%입니다. 또한 총 구매 횟수는 3입니다.
3번 상품을 구입한 고객은 3번 고객과 4번 고객입니다. 4번 고객은 3번 상품을 한 번 구매한 고객이며, 3번 고객은 3번 상품을 세 번 구매한 고객입니다. 따라서 재구매율은 50%입니다. 또한 총 구매 횟수는 4입니다.
4번 상품은 조사하고자 하는 기간 내에 구매한 기록이 없으므로 고려하지 않습니다.
상품을 재구매율을 기준으로 내림차순 정렬합니다. 재구매율이 같다면 총 구매 횟수가 높은 순으로, 총 구매 횟수까지 같다면 상품 아이디가 낮은 순으로 정렬합니다. 1번 상품은 재구매율이 100%이므로 1위, 3번 상품은 2번 상품과 재구매율이 50%로 같지만 총 구매 횟수가 더 많기 때문에 2위, 2번 상품은 3위입니다. 따라서 상품을 pid1, pid3, pid2 순으로 정렬할 수 있습니다.

구매 기록을 담은 문자열 배열 records, 재구매 기간을 나타내는 정수 k, 재구매율을 계산하는 기준 날짜를 나타내는 문자열 date가 매개변수로 주어집니다. 재구매율을 기준으로 내림차순 정렬한 상품 아이디를 배열에 담아 return 하도록 solution 함수를 완성해주세요. 단, 재구매율이 같다면 총 구매 횟수로 내림차순 정렬하며, 총 구매 횟수가 같다면 상품 아이디의 번호를 기준으로 오름차순 정렬해주세요. 빈 배열을 반환하는 경우, 문자열 "no result"를 배열에 담아 return 해주세요.

제한사항
1 ≤ records의 길이 ≤ 100,000
records의 원소는 "날짜 uid유저번호 pid상품번호" 형식이며 하나의 공백으로 구분되어 있습니다.
날짜는 YYYY-MM-DD 형식이며 2020-01-01과 2020-12-30 사이에 있습니다.
모든 달은 30일까지 존재합니다. 즉, 1월과 같이 31일까지 존재하는 달도 30일까지만 존재한다고 가정합니다.
records는 날짜를 기준으로 오름차순 정렬되어 있습니다.
1 ≤ 유저번호 ≤ 100,000
1 ≤ 상품번호 ≤ 100,000
유저번호와 상품번호는 숫자로만 이루어져 있습니다.
10 ≤ k ≤ 365
date는 YYYY-MM-DD 형식이며 2020-01-01과 2020-12-30 사이에 있습니다.
2월 30일과 같이 실제로 존재하지 않는 날짜도 주어질 수 있습니다.
입출력 예
records	k	date	result
["2020-02-02 uid1 pid1", "2020-02-26 uid1 pid1", "2020-02-26 uid2 pid1", "2020-02-27 uid3 pid2", "2020-02-28 uid4 pid2", "2020-02-29 uid3 pid3", "2020-03-01 uid4 pid3", "2020-03-03 uid1 pid1", "2020-03-04 uid2 pid1", "2020-03-05 uid3 pid2", "2020-03-05 uid3 pid3", "2020-03-05 uid3 pid3", "2020-03-06 uid1 pid4"]	10	"2020-03-05"	["pid1", "pid3", "pid2"]
["2020-02-02 uid141 pid141", "2020-02-03 uid141 pid32", "2020-02-04 uid32 pid32", "2020-02-05 uid32 pid141"]	10	"2020-02-05"	["pid32", "pid141"]
["2020-01-01 uid1000 pid5000"]	10	"2020-01-11"	["no result"]
